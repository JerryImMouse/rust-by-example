# Литералы и операторы

Целочисленное `1`, вещественное `1.2`, символ `'a'`, строка `"abc"`, логическое `true` и единичный тип `()` могут быть выражены с помощью литералов.

Целочисленные значения так же могут быть выражены с помощью шестнадцатеричного, восьмеричного или двоичного обозначения используя соответствующие префиксы: `0x`, `0o` или `0b`.

Для улучшения читаемости числовых литералов можно использовать подчёркивания, например `1_000` тоже самое, что и `1000`, и `0.000_001` равно `0.000001`.

Нам необходимо указать компилятору какой тип для литерала мы используем. Сейчас мы используем суффикс `u32`, чтобы указать, что литерал - беззнаковое целое число 32-х бит и суффикс `i32` - знаковое целое 32-х битное число.

Доступные операторы и их приоритет [в Rust](https://doc.rust-lang.org/reference/expressions.html#expression-precedence) такой же как и в других [C-подобных языках](https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages).

```rust,editable
fn main() {
    // Целочисленное сложение
    println!("1 + 2 = {}", 1u32 + 2);

    // Целочисленное вычитание
    println!("1 - 2 = {}", 1i32 - 2);
    // ЗАДАНИЕ ^ Попробуйте изменить `1i32` на `1u32`
    // чтобы убедится насколько важен тип данных

    // Булева логика
    println!("true И false будет {}", true && false);
    println!("true ИЛИ false будет {}", true || false);
    println!("НЕ true будет {}", !true);

    // Побитовые операции
    println!("0011 И 0101 будет {:04b}", 0b0011u32 & 0b0101);
    println!("0011 ИЛИ 0101 будет {:04b}", 0b0011u32 | 0b0101);
    println!("0011 исключающее ИЛИ 0101 будет {:04b}", 0b0011u32 ^ 0b0101);
    println!("1 << 5 будет {}", 1u32 << 5);
    println!("0x80 >> 2 будет 0x{:x}", 0x80u32 >> 2);

    // Использование подчёркивания для улучшения читаемости!
    println!("Один миллион записан как {}", 1_000_000u32);
}
```
